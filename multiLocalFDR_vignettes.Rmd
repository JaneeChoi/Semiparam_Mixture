---
title: "Getting started with multiLocalFDR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with httr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
library(httr)
knitr::opts_chunk$set(comment = "#>", collapse = TRUE)
```

# multiLocalFDR quickstart guide

The goal of this document is to get you up and running with `multiLocalFDR` as quickly as possible. httr is designed to map closely to the underlying http protocol. I'll try and explain the basics in this intro, but I'd also recommend "[HTTP: The Protocol Every Web Developer Must Know][http-tutorial]" or "[HTTP made really easy](https://www.jmarshall.com/easy/http/)".

There are two important parts to http: the __request__, the data sent to the server, and the __response__, the data sent back from the server. In the first section, you'll learn about the basics of constructing a request and accessing the response. In the second and third sections, you'll dive into more details of each.

## Installation

```{r}
library(devtools)
install_github("JungiinChoi/multiLocalFDR")
```

You can pull out important parts of the response with various helper methods, or dig directly into the object:

```{r}
library(multiLocalFDR)
?multiLocalFDR
```

I'll use `httpbin.org` throughout this introduction. It accepts many types of http request and returns json that describes the data that it received. This makes it easy to see what httr is doing.

As well as `GET()`, you can also use the `HEAD()`, `POST()`, `PATCH()`, `PUT()` and `DELETE()` verbs. You're probably most familiar with `GET()` and `POST()`: `GET()` is used by your browser when requesting a page, and `POST()` is (usually) used when submitting a form to a server. `PUT()`, `PATCH()` and `DELETE()` are used most often by web APIs.

## Simulations

The data sent back from the server consists of three parts: the status line, the headers and the body. The most important part of the status line is the http status code: it tells you whether or not the request was successful. I'll show you how to access that data, then how to access the body and headers.

### 1-dimensional Normal

The status code is a three digit number that summarises whether or not the request was successful (as defined by the server that you're talking to). You can access the status code along with a descriptive message using `http_status()`:

```{r, eval=FALSE}
r <- GET("http://httpbin.org/get")
# Get an informative description:
http_status(r)

# Or just access the raw code:
r$status_code
```

A successful request always returns a status of 200. Common errors are 404 (file not found) and 403 (permission denied). If you're talking to web APIs you might also see 500, which is a generic failure code (and thus not very helpful). If you'd like to learn more, the most memorable guides are the [http status cats](https://www.flickr.com/photos/girliemac/sets/72157628409467125).

You can automatically throw a warning or raise an error if a request did not succeed:

```{r, eval=FALSE}
warn_for_status(r)
stop_for_status(r)
```

I highly recommend using one of these functions whenever you're using httr inside a function (i.e. not interactively) to make sure you find out about errors as soon as possible.

### 1-dimensional Gamma

There are three ways to access the body of the request, all using `content()`:

*   `content(r, "text")` accesses the body as a character vector:

    ```{r, eval=FALSE}
    r <- GET("http://httpbin.org/get")
    content(r, "text")
    ```

    httr will automatically decode content from the server using the encoding 
    supplied in the `content-type` HTTP header. Unfortunately you can't always 
    trust what the server tells you, so you can override encoding if needed:

    ```{r, eval = FALSE}
    content(r, "text", encoding = "ISO-8859-1")
    ```

    If you're having problems figuring out what the correct encoding 
    should be, try `stringi::stri_enc_detect(content(r, "raw"))`.

## Case Studies

### Pathways

A common way of sending simple key-value pairs to the server is the query string: e.g. `http://httpbin.org/get?key=val`. httr allows you to provide these arguments as a named list with the `query` argument. For example, if you wanted to pass `key1=value1` and `key2=value2` to `http://httpbin.org/get` you could do:

```{r, eval=FALSE}
## Data
data("pathways", package = "multiLocalFDR")
head(pathways)

> head(pathways)
                            Gene.Set        L         O         S
1        Neutrophil degranulation(R) 3.14e-13 3.280e-09 1.110e-16
2          Antimicrobial peptides(R) 7.69e-06 1.140e-03 1.310e-03
3    Toll-Like Receptors Cascades(R) 1.85e-05 3.390e-03 2.780e-04
4       Signaling by Interleukins(R) 8.91e-05 1.880e-05 8.240e-08
5 Fructose and mannose metabolism(K) 4.21e-04 2.865e-01 4.490e-01
6   IL4-mediated signaling events(N) 5.47e-04 5.040e-04 1.065e-01

```

Any `NULL` elements are automatically dropped from the list, and both keys and values are escaped automatically.

```{r, eval=FALSE}
## SpMix for each pathway
params_L <- SpMix(pathways[,2], p_value = TRUE, tol = 1e-10)

> params_L <- SpMix(pathways[,2], p_value = TRUE, tol = 1e-10)
   EM iteration: 1 , Change in fdr fit =  0 
   EM iteration: 2 , Change in fdr fit =  0 
   EM iteration: 3 , Change in fdr fit =  0 
   EM iteration: 4 , Change in fdr fit =  0 
   EM iteration: 5 , Change in fdr fit =  0 
   EM iteration: 6 , Change in fdr fit =  0 
   EM iteration: 7 , Change in fdr fit =  0 
   
params_O <- SpMix(pathways[,3], p_value = TRUE, tol = 1e-10)

> params_O <- SpMix(pathways[,3], p_value = TRUE, tol = 1e-10)
   EM iteration: 1 , Change in fdr fit =  0.00095 
   EM iteration: 2 , Change in fdr fit =  0.00092 
   EM iteration: 3 , Change in fdr fit =  0 
   EM iteration: 4 , Change in fdr fit =  0 
   EM iteration: 5 , Change in fdr fit =  0 
   EM iteration: 6 , Change in fdr fit =  0 
   EM iteration: 7 , Change in fdr fit =  0 
   EM iteration: 8 , Change in fdr fit =  0 
   EM iteration: 9 , Change in fdr fit =  0 
   EM iteration: 10 , Change in fdr fit =  0 
   EM iteration: 11 , Change in fdr fit =  0 
   EM iteration: 12 , Change in fdr fit =  0 
   EM iteration: 13 , Change in fdr fit =  0 
   EM iteration: 14 , Change in fdr fit =  0 
   EM iteration: 15 , Change in fdr fit =  0 
   EM iteration: 16 , Change in fdr fit =  0 
   EM iteration: 17 , Change in fdr fit =  0 
   EM iteration: 18 , Change in fdr fit =  0 
   EM iteration: 19 , Change in fdr fit =  0 
   EM iteration: 20 , Change in fdr fit =  0 
   EM iteration: 21 , Change in fdr fit =  0 
   EM iteration: 22 , Change in fdr fit =  0 
   EM iteration: 23 , Change in fdr fit =  0 
   EM iteration: 24 , Change in fdr fit =  0 
   EM iteration: 25 , Change in fdr fit =  0 
   EM iteration: 26 , Change in fdr fit =  0 
   EM iteration: 27 , Change in fdr fit =  0 
   EM iteration: 28 , Change in fdr fit =  0 
   EM iteration: 29 , Change in fdr fit =  0 
   EM iteration: 30 , Change in fdr fit =  0 
   
params_S <- SpMix(pathways[,4], p_value = TRUE, tol = 1e-10)

> params_S <- SpMix(pathways[,4], p_value = TRUE, tol = 1e-10)
   EM iteration: 1 , Change in fdr fit =  0 
   EM iteration: 2 , Change in fdr fit =  0 
   EM iteration: 3 , Change in fdr fit =  0 
   EM iteration: 4 , Change in fdr fit =  0 
   EM iteration: 5 , Change in fdr fit =  0 
   EM iteration: 6 , Change in fdr fit =  0 
   EM iteration: 7 , Change in fdr fit =  0 
   EM iteration: 8 , Change in fdr fit =  0 
   EM iteration: 9 , Change in fdr fit =  0 
   EM iteration: 10 , Change in fdr fit =  0 
   EM iteration: 11 , Change in fdr fit =  0 
   EM iteration: 12 , Change in fdr fit =  0 
   EM iteration: 13 , Change in fdr fit =  0 
   EM iteration: 14 , Change in fdr fit =  0 
   EM iteration: 15 , Change in fdr fit =  0 
   EM iteration: 16 , Change in fdr fit =  0 
   EM iteration: 17 , Change in fdr fit =  0 
   EM iteration: 18 , Change in fdr fit =  0 
   EM iteration: 19 , Change in fdr fit =  0 
   EM iteration: 20 , Change in fdr fit =  0 
   EM iteration: 21 , Change in fdr fit =  0 
   EM iteration: 22 , Change in fdr fit =  0 
   EM iteration: 23 , Change in fdr fit =  0 
   EM iteration: 24 , Change in fdr fit =  0 
   EM iteration: 25 , Change in fdr fit =  0 
   EM iteration: 26 , Change in fdr fit =  0 
   EM iteration: 27 , Change in fdr fit =  0 
   EM iteration: 28 , Change in fdr fit =  0 
   EM iteration: 29 , Change in fdr fit =  0 
   EM iteration: 30 , Change in fdr fit =  0 
   
```

```{r, eval=FALSE}
## Plot results for each pathway
plotFDR(pathways[,2], params_L$p0, params_L$mu0, params_L$sig0, params_L$f1, 
        params_L$localFDR, p_value = TRUE)
plotFDR(pathways[,3], params_O$p0, params_O$mu0, params_O$sig0, params_O$f1, 
        params_O$localFDR, p_value = TRUE)
plotFDR(pathways[,4], params_S$p0, params_S$mu0, params_S$sig0, params_S$f1, 
        params_S$localFDR, p_value = TRUE)
```

```{r, eval=FALSE}
## SpMix for 3-dimensional data
params_LOS <- SpMix(pathways[,2:4], p_value = TRUE)
```

```{r, eval=FALSE}
## SpMix for each pathway
params_LOS <- SpMix(pathways[,2], p_value = TRUE, tol = 1e-10)
```

### Galaxy Velocity

You can add custom headers to a request with `add_headers()`:

```{r, eval=FALSE}
# Data
data("galaxy", package = "multiLocalFDR")
head(galaxy)

> head(galaxy)
radius  velocity
1  9.900000 1034.0669
2 20.129999 1013.8658
3 12.640000 1055.4016
4 12.160000  776.8124
5  9.979999 1606.6024
6 11.490000  774.1326
```

```{r, eval=FALSE}
## transform to z-values
z_galaxy <- scale(galaxy$velocity)[,1]
head(z_galaxy)

> head(z_galaxy)
[1] 0.9969051 0.9579670 1.0380283 0.5010402 2.1004827 0.4958748
```

```{r, eval=FALSE}
## SpMix for galaxy data
params <- SpMix(z_galaxy, alternative = "less")

> params <- SpMix(z_galaxy, alternative = "less")
EM iteration: 1 , Change in fdr fit =  0.95717 
EM iteration: 2 , Change in fdr fit =  0.04283 
EM iteration: 3 , Change in fdr fit =  0 
```

```{r, eval=FALSE}
## Plot results
plotFDR(z_galaxy, params$p0, params$mu0, params$sig0, params$f1, 
        params$localFDR, alternative = "less", thre_localFDR = 0.2, testing = FALSE)

```

(Note that `content(r)$header` retrieves the headers that httpbin received. `headers(r)` gives the headers that it sent back in its response.)

### Microarrays

Cookies are simple key-value pairs like the query string, but they persist across multiple requests in a session (because they're sent back and forth every time). To send your own cookies to the server, use `set_cookies()`:

```{r}
r <- GET("http://httpbin.org/cookies", set_cookies("MeWant" = "cookies"))
content(r)$cookies
```


##### Built with

```{r}
sessionInfo()
```

[http-tutorial]:https://code.tutsplus.com/tutorials/http-the-protocol-every-web-developer-must-know-part-1--net-31177